# TypeScript Type Patterns & Best Practices

**Last Updated:** November 2025
**Project:** Autolytiq Stabilization

## Table of Contents

1. [Zero 'any' Policy](#zero-any-policy)
2. [Type Inference with Zod](#type-inference-with-zod)
3. [Creating Input Types](#creating-input-types)
4. [Database Type Patterns](#database-type-patterns)
5. [Error Handling Types](#error-handling-types)
6. [API Response Types](#api-response-types)
7. [Common Anti-Patterns](#common-anti-patterns)

---

## Zero 'any' Policy

**NEVER use `any` type in production code.**

### What to use instead:

```typescript
// ❌ WRONG
function processData(data: any) {
  return data.value;
}

// ✅ CORRECT - Use unknown for truly unknown data
function processData(data: unknown): string {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return String(data.value);
  }
  throw new Error('Invalid data structure');
}

// ✅ CORRECT - Use generic constraints
function processData<T extends { value: string }>(data: T): string {
  return data.value;
}

// ✅ CORRECT - Use Record for objects
function processData(data: Record<string, unknown>): string {
  return String(data.value);
}
```

---

## Type Inference with Zod

Use Zod schemas as the single source of truth for types.

### Pattern

```typescript
import { z } from 'zod';

// 1. Define Zod schema
export const CustomerSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1),
  email: z.string().email(),
  phone: z.string().optional(),
  createdAt: z.string().datetime(),
});

// 2. Infer TypeScript type from schema
export type Customer = z.infer<typeof CustomerSchema>;

// 3. Use in functions
function createCustomer(data: Customer): void {
  // TypeScript knows exact shape of data
  console.log(data.name); // ✅ Type-safe
}
```

### Benefits

- **Single source of truth**: Schema = validation + types
- **Runtime safety**: Zod validates at runtime
- **Auto-completion**: Full IDE support
- **Refactor-safe**: Change schema, types update automatically

---

## Creating Input Types

### Omit Pattern (for create operations)

```typescript
// Schema for full entity
export const VehicleSchema = z.object({
  id: z.string().uuid(),
  vin: z.string().length(17),
  make: z.string(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
});

// Input type omits system-generated fields
export const CreateVehicleSchema = VehicleSchema.omit({
  id: true,        // Generated by database
  createdAt: true, // Generated by database
  updatedAt: true, // Generated by database
});

export type Vehicle = z.infer<typeof VehicleSchema>;
export type CreateVehicleInput = z.infer<typeof CreateVehicleSchema>;

// Usage
async function createVehicle(input: CreateVehicleInput): Promise<Vehicle> {
  const validated = CreateVehicleSchema.parse(input); // Runtime validation
  return await db.insert(vehicles).values(validated);
}
```

### Partial Pattern (for update operations)

```typescript
// All fields optional except version (for optimistic locking)
export const UpdateVehicleSchema = CreateVehicleSchema.partial().extend({
  version: z.number(), // Required for optimistic locking
});

export type UpdateVehicleInput = z.infer<typeof UpdateVehicleSchema>;
```

---

## Database Type Patterns

### JSONB Column Types

PostgreSQL `jsonb` columns are typed as `unknown` in Drizzle. Cast appropriately:

```typescript
// ❌ WRONG
toAddresses: validated.to as any,

// ✅ CORRECT
toAddresses: validated.to as unknown,

// Then type-guard when reading
const addresses = Array.isArray(row.toAddresses)
  ? row.toAddresses
  : [];
```

### Database Row Mappers

```typescript
// ❌ WRONG
private mapRowToCustomer(row: any): Customer {
  return {
    id: row.id,
    name: row.name,
  };
}

// ✅ CORRECT
private mapRowToCustomer(row: Record<string, unknown>): Customer {
  // Validate with Zod before returning
  return CustomerSchema.parse({
    id: row.id,
    name: row.name,
    email: row.email,
    // ...
  });
}
```

### Storage Interface Patterns

```typescript
// ❌ WRONG
export interface CustomerStorage {
  createCustomer(data: any): Promise<Customer>;
  updateCustomer(id: string, data: any): Promise<Customer>;
}

// ✅ CORRECT
export interface CustomerStorage {
  createCustomer(data: CreateCustomerInput): Promise<Customer>;
  updateCustomer(id: string, data: UpdateCustomerInput): Promise<Customer>;
}
```

---

## Error Handling Types

### Catch Block Pattern

```typescript
// ❌ WRONG
} catch (error: any) {
  console.error(error.message);
  res.status(500).json({ error: error.message });
}

// ✅ CORRECT
} catch (error) {
  const message = error instanceof Error ? error.message : 'Unknown error';
  console.error(message);
  res.status(500).json({ error: message });
}

// ✅ BETTER - Use type guard helper
function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message;
  if (typeof error === 'string') return error;
  return 'Unknown error';
}

} catch (error) {
  const message = getErrorMessage(error);
  console.error(message);
}
```

### Custom Error Types

```typescript
// Define custom error with typed details
export class ValidationError extends Error {
  constructor(
    message: string,
    public details: Record<string, unknown> // ✅ NOT any
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

// Usage with type guard
if (error instanceof ValidationError) {
  console.log(error.details); // ✅ Typed as Record<string, unknown>
}
```

---

## API Response Types

### Standard Response Pattern

```typescript
// Centralized in /shared/types/index.ts
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  code?: string;
}

export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  hasMore: boolean;
}

// Usage
async function listCustomers(
  query: CustomerListQuery
): Promise<PaginatedResponse<Customer>> {
  const customers = await db.query.customers.findMany();
  return {
    data: customers,
    total: customers.length,
    page: query.page,
    limit: query.limit,
    hasMore: customers.length === query.limit,
  };
}
```

### Express Request Extensions

```typescript
// Extend Express types globally
declare global {
  namespace Express {
    interface User {
      id: string;
      email: string;
      role: string;
      preferences: Record<string, unknown>; // ✅ NOT any
    }
  }
}

// Type-safe session
interface AuthSession {
  userId?: string;
  pending2faUserId?: string;
}

(req.session as AuthSession).userId = user.id;
```

---

## Common Anti-Patterns

### Anti-Pattern 1: Using 'any' for JSON data

```typescript
// ❌ WRONG
const json: any = JSON.parse(input);
console.log(json.value);

// ✅ CORRECT
const json: unknown = JSON.parse(input);
if (typeof json === 'object' && json !== null && 'value' in json) {
  console.log(json.value);
}

// ✅ BETTER - Use Zod
const JsonSchema = z.object({
  value: z.string(),
});
const json = JsonSchema.parse(JSON.parse(input));
console.log(json.value); // ✅ Type-safe
```

### Anti-Pattern 2: Untyped function parameters

```typescript
// ❌ WRONG
function processUser(data: any) {
  return { name: data.name };
}

// ✅ CORRECT
interface UserData {
  name: string;
  email: string;
}

function processUser(data: UserData) {
  return { name: data.name };
}
```

### Anti-Pattern 3: Type assertions without validation

```typescript
// ❌ WRONG
const user = req.user as User;
console.log(user.email);

// ✅ CORRECT
if (!req.user) {
  throw new Error('User not authenticated');
}
const user = req.user; // TypeScript knows user exists
console.log(user.email);
```

### Anti-Pattern 4: Overly permissive object types

```typescript
// ❌ WRONG
interface Config {
  [key: string]: any;
}

// ✅ CORRECT - Explicit properties, unknown for extras
interface Config {
  apiKey: string;
  timeout: number;
  [key: string]: unknown; // Extra properties are unknown, not any
}

// ✅ BETTER - No index signature if structure is known
interface Config {
  apiKey: string;
  timeout: number;
  retries?: number;
}
```

---

## Type Hierarchy

**From most restrictive to least restrictive:**

1. **Literal types** - `'admin' | 'user'`
2. **Specific types** - `string`, `number`, `User`
3. **Union types** - `string | number`
4. **`unknown`** - Requires type checking before use
5. **`any`** - ❌ NEVER USE

---

## Quick Reference

| Situation | Type to Use |
|-----------|-------------|
| Function parameter with unclear shape | `unknown` |
| Database row result | `Record<string, unknown>` |
| JSON parsing | `unknown` + Zod validation |
| Error in catch block | `unknown` + type guard |
| User preferences | `Record<string, unknown>` |
| JSONB column value | `unknown` (cast from Drizzle) |
| Dynamic object keys | `Record<string, T>` |
| Lazy-loaded relations | `unknown` (comment as lazy) |

---

## Migration Checklist

When removing 'any' types:

- [ ] Identify the actual data shape
- [ ] Create or find existing Zod schema
- [ ] Use `z.infer<typeof Schema>` for type
- [ ] Add runtime validation where needed
- [ ] Add type guards for narrowing
- [ ] Test with TypeScript strict mode
- [ ] Verify no type errors

---

## Resources

- **Zod Documentation**: https://zod.dev
- **TypeScript Handbook**: https://www.typescriptlang.org/docs/handbook/
- **Type Guards**: https://www.typescriptlang.org/docs/handbook/2/narrowing.html

---

**Remember**: Every `any` type is a type error waiting to happen in production. Take the extra 2 minutes to type it properly.
